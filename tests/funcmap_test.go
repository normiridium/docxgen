package tests

import (
	"docxgen/modifiers"
	"reflect"
	"testing"
)

// sliceToValues ‚Äî –¥–ª—è reflect.Call
func sliceToValues(in []any) []reflect.Value {
	out := make([]reflect.Value, len(in))
	for i, v := range in {
		out[i] = reflect.ValueOf(v)
	}
	return out
}

// TestBuiltinsSignature ‚Äî —Å—Ç—Ä–æ–≥–∏–π smoke-—Ç–µ—Å—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤.
// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–æ—á–Ω–æ —Ä–∞–≤–µ–Ω –æ–∂–∏–¥–∞–µ–º–æ–º—É.
func TestBuiltinsSignature(t *testing.T) {
	fm := modifiers.NewFuncMap(modifiers.Options{})

	tests := []struct {
		name string
		args []any
		want string
	}{
		// ---------- string mods ----------
		{"prefix", []any{"–≥—Ä–∞–∂–¥–∞–Ω–∏–Ω ", "–ò–≤–∞–Ω–æ–≤"}, "–≥—Ä–∞–∂–¥–∞–Ω–∏–Ω –ò–≤–∞–Ω–æ–≤"},
		{"uniq_prefix", []any{"–û–û–û ", "–û–û–û –†–æ–º–∞—à–∫–∞"}, "–û–û–û –†–æ–º–∞—à–∫–∞"},
		{"postfix", []any{" —Ä—É–±.", "100"}, "100 —Ä—É–±."},
		{"uniq_postfix", []any{" –≥.", "–ú–æ—Å–∫–≤–∞ –≥."}, "–ú–æ—Å–∫–≤–∞ –≥."},
		{"default", []any{"—Å–æ—Ç—Ä—É–¥–Ω–∏–∫", ""}, "—Å–æ—Ç—Ä—É–¥–Ω–∏–∫"},
		{"filled", []any{"‚Äî", "–ø–∞—Å–ø–æ—Ä—Ç"}, "‚Äî"},
		{"replace", []any{"–ü–µ—Ç–µ—Ä–±—É—Ä–≥", "–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥", "–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥"}, "–°–∞–Ω–∫—Ç-–õ–µ–Ω–∏–Ω–≥—Ä–∞–¥"},
		{"truncate", []any{5, "...", "–û—á–µ–Ω—å –¥–ª–∏–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞"}, "–û—á–µ–Ω—å..."},
		{"word_reverse", []any{"–§–∞–º–∏–ª–∏—è –ò–º—è –û—Ç—á–µ—Å—Ç–≤–æ"}, "–û—Ç—á–µ—Å—Ç–≤–æ –ò–º—è –§–∞–º–∏–ª–∏—è"},

		// ---------- text mods ----------
		{"nowrap", []any{"–≥. –ú–æ—Å–∫–≤–∞"}, "–≥.\u00A0–ú–æ—Å–∫–≤–∞"},
		{"compact", []any{"+7 900 123 45 67"}, "+7\u202f900\u202f123\u202f45\u202f67"},
		{"abbr", []any{"–ò. –ò. –ò–≤–∞–Ω–æ–≤"}, "–ò.\u00a0–ò.\u00a0–ò–≤–∞–Ω–æ–≤"},
		{"abbr", []any{"–û–û–û –¶–µ–Ω—Ç—Ä"}, "–û–û–û\u00a0–¶–µ–Ω—Ç—Ä"},
		{"ru_phone", []any{"+7 (900) 123-45-67"}, "+7 (900) 123-45-67"},
		{"ru_phone", []any{"89001234567"}, "+7 (900) 123-45-67"},
		{"ru_phone", []any{"8 (4912) 572466"}, "+7 (4912) 572-466"},

		// ---------- numeric mods ----------
		{"numeral", []any{5}, "–ø—è—Ç—å"},
		{"plural", []any{"–¥–µ–Ω—å", "–¥–Ω—è", "–¥–Ω–µ–π", 1}, "–¥–µ–Ω—å"},
		{"plural", []any{"—Ñ–∞–π–ª", "—Ñ–∞–π–ª–∞", "—Ñ–∞–π–ª–æ–≤", 3}, "—Ñ–∞–π–ª–∞"},
		{"plural", []any{"—Ñ–∞–π–ª", "—Ñ–∞–π–ª–∞", "—Ñ–∞–π–ª–æ–≤", 10}, "—Ñ–∞–π–ª–æ–≤"},
		{"sign", []any{5}, "+5"},
		{"sign", []any{-3}, "-3"},
		{"sign", []any{0}, "0"},
		{"pad_left", []any{5, "0", "42"}, "00042"},
		{"pad_left", []any{3, " ", "42"}, " 42"},
		{"pad_right", []any{5, "0", "42"}, "42000"},
		{"pad_right", []any{4, " ", "42"}, "42  "},
		{"money", []any{12345.67}, "12 345,67"},
		{"money", []any{"int", 12345.00}, "12 345"},
		{"money", []any{"%s —Ä—É–±–ª–µ–π %02d –∫–æ–ø–µ–µ–∫", 12345.67}, "12 345 —Ä—É–±–ª–µ–π 67 –∫–æ–ø–µ–µ–∫"},
		{"roman", []any{14}, "XIV"},
		{"roman", []any{1}, "I"},
		{"roman", []any{3999}, "MMMCMXCIX"},

		// ---------- declension mods ----------
		{"declension", []any{"–≤–∏–Ω–∏—Ç–µ–ª—å–Ω—ã–π", "—Ñ –∏ –æ", "–ö—É–∑–Ω–µ—Ü–æ–≤–∞ –ú–∞—Ä–∏—è –°–µ—Ä–≥–µ–µ–≤–Ω–∞"}, "–ö—É–∑–Ω–µ—Ü–æ–≤—É –ú–∞—Ä–∏—é –°–µ—Ä–≥–µ–µ–≤–Ω—É"},
		{"declension", []any{"–¥–∞—Ç–µ–ª—å–Ω—ã–π", "—Ñ–∞–º–∏–ª–∏—è –∏.–æ.", "–ò–≤–∞–Ω–æ–≤ –ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤–∏—á"}, "–ò–≤–∞–Ω–æ–≤—É –ò.–ò."},
		{"decl", []any{"–ø—Ä–µ–¥–ª–æ–∂–Ω—ã–π", "—Ñ–∞–º–∏–ª–∏—è", "–ü–µ—Ç—Ä–æ–≤ –ü–µ—Ç—Ä –ü–µ—Ç—Ä–æ–≤–∏—á"}, "–ü–µ—Ç—Ä–æ–≤–µ"},
		{"decl", []any{"—Ä–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π", "", "–°–º–∏—Ä–Ω–æ–≤ –ê–Ω–¥—Ä–µ–π"}, "–°–º–∏—Ä–Ω–æ–≤–∞ –ê–Ω–¥—Ä–µ—è"},

		// ---------- date mods ----------
		{"date_format", []any{"02.01.2006", "2025-10-26"}, "26.10.2025"},
		{"date_format", []any{"2006/01/02", "2025/03/14"}, "2025/03/14"},
		{"date_format", []any{"02.01.2006 15:04", "2025-10-14T22:15:00Z"}, "14.10.2025 22:15"},
	}

	for _, tt := range tests {
		fn, ok := fm[tt.name]
		if !ok {
			t.Errorf("‚ùå %s ‚Äî –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ FuncMap", tt.name)
			continue
		}

		t.Run(tt.name, func(t *testing.T) {
			defer func() {
				if r := recover(); r != nil {
					t.Errorf("üí• %s ‚Äî –ø–∞–Ω–∏–∫–∞: %v", tt.name, r)
				}
			}()

			out := reflect.ValueOf(fn).Call(sliceToValues(tt.args))
			if len(out) == 0 {
				t.Errorf("‚ö†Ô∏è %s –Ω–∏—á–µ–≥–æ –Ω–µ –≤–µ—Ä–Ω—É–ª", tt.name)
				return
			}

			got := out[0].Interface()
			s, ok := got.(string)
			if !ok {
				t.Errorf("‚ÑπÔ∏è %s ‚Üí %#v (non-string)", tt.name, got)
				return
			}

			if s != tt.want {
				t.Errorf("‚ùå %s: –æ–∂–∏–¥–∞–ª–æ—Å—å %q, –ø–æ–ª—É—á–µ–Ω–æ %q", tt.name, tt.want, s)
			}
		})
	}

}
